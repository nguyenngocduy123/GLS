(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/forms'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('ngx-custom-validators', ['exports', '@angular/forms', '@angular/core'], factory) :
    (factory((global['ngx-custom-validators'] = {}),global.ng.forms,global.ng.core));
}(this, (function (exports,forms,core) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} obj
     * @return {?}
     */
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function isDate(obj) {
        try {
            /** @type {?} */
            var date = new Date(obj);
            return !isNaN(date.getTime());
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function parseDate(obj) {
        try {
            // Moment.js
            if (obj._d instanceof Date) {
                /** @type {?} */
                var d = /** @type {?} */ (obj._d);
                /** @type {?} */
                var month = +d.getMonth() + 1;
                /** @type {?} */
                var day = +d.getDate();
                return d.getFullYear() + "-" + formatDayOrMonth(month) + "-" + formatDayOrMonth(day);
            }
            // NgbDateStruct
            if (typeof obj === 'object' && obj.year != null && obj.month != null && obj.day != null) {
                /** @type {?} */
                var month = +obj.month;
                /** @type {?} */
                var day = +obj.day;
                return obj.year + "-" + formatDayOrMonth(month) + "-" + formatDayOrMonth(day);
            }
        }
        catch (e) { }
        return obj;
    }
    /**
     * @param {?} month
     * @return {?}
     */
    function formatDayOrMonth(month) {
        return month < 10 ? "0" + month : month;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var arrayLength = function (value) {
        return function (control) {
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var obj = control.value;
            return Array.isArray(obj) && obj.length >= +value ? null : { arrayLength: { minLength: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var base64 = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        return /^(?:[A-Z0-9+\/]{4})*(?:[A-Z0-9+\/]{2}==|[A-Z0-9+\/]{3}=|[A-Z0-9+\/]{4})$/i.test(v) ? null : { base64: true };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var creditCard = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        /** @type {?} */
        var sanitized = v.replace(/[^0-9]+/g, '');
        // problem with chrome
        /* tslint:disable */
        if (!(/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|(?:9792)\d{12})$/.test(sanitized))) {
            return { creditCard: true };
        }
        /** @type {?} */
        var sum = 0;
        /** @type {?} */
        var digit;
        /** @type {?} */
        var tmpNum;
        /** @type {?} */
        var shouldDouble;
        for (var i = sanitized.length - 1; i >= 0; i--) {
            digit = sanitized.substring(i, (i + 1));
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += ((tmpNum % 10) + 1);
                }
                else {
                    sum += tmpNum;
                }
            }
            else {
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        if (Boolean((sum % 10) === 0 ? sanitized : false)) {
            return null;
        }
        return { creditCard: true };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var date = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        v = parseDate(v);
        return isDate(v) ? null : { date: true };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var dateISO = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(v) ? null : { dateISO: true };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var digits = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        return /^\d+$/.test(v) ? null : { digits: true };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var email = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        /* tslint:disable */
        return /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v) ? null : { 'email': true };
        /* tslint:enable */
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var equal = function (val) {
        return function (control) {
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = control.value;
            return val === v ? null : { equal: { value: val } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var equalTo = function (equalControl) {
        /** @type {?} */
        var subscribe = false;
        return function (control) {
            if (!subscribe) {
                subscribe = true;
                equalControl.valueChanges.subscribe(function () {
                    control.updateValueAndValidity();
                });
            }
            /** @type {?} */
            var v = control.value;
            return equalControl.value === v ? null : { equalTo: { control: equalControl, value: equalControl.value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var gt = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v > +value ? null : { gt: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var gte = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v >= +value ? null : { gte: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var json = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        try {
            /** @type {?} */
            var obj = JSON.parse(v);
            if (Boolean(obj) && typeof obj === 'object') {
                return null;
            }
        }
        catch (e) { }
        return { json: true };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var lt = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v < +value ? null : { lt: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var lte = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v <= +value ? null : { lte: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var max = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v <= +value ? null : { max: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var maxDate = function (maxInput) {
        /** @type {?} */
        var value;
        /** @type {?} */
        var subscribe = false;
        /** @type {?} */
        var maxValue = maxInput;
        /** @type {?} */
        var isForm = maxInput instanceof forms.FormControl || maxInput instanceof forms.NgModel;
        return function (control) {
            if (!subscribe && isForm) {
                subscribe = true;
                maxInput.valueChanges.subscribe(function () {
                    control.updateValueAndValidity();
                });
            }
            if (isForm) {
                maxValue = maxInput.value;
            }
            value = parseDate(maxValue);
            if (!isDate(value) && !(value instanceof Function)) {
                if (value == null) {
                    return null;
                }
                else if (isForm) {
                    return { maxDate: { error: 'maxDate is invalid' } };
                }
                else {
                    throw Error('maxDate value must be or return a formatted date');
                }
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var d = new Date(parseDate(control.value)).getTime();
            if (!isDate(d)) {
                return { value: true };
            }
            if (value instanceof Function) {
                value = value();
            }
            return d <= new Date(value).getTime() ? null : (isForm ? { maxDate: { control: maxInput, value: maxInput.value } } : { maxDate: { value: maxValue, control: undefined } });
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var min = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v >= +value ? null : { min: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var minDate = function (minInput) {
        /** @type {?} */
        var value;
        /** @type {?} */
        var subscribe = false;
        /** @type {?} */
        var minValue = minInput;
        /** @type {?} */
        var isForm = minInput instanceof forms.FormControl || minInput instanceof forms.NgModel;
        return function (control) {
            if (!subscribe && isForm) {
                subscribe = true;
                minInput.valueChanges.subscribe(function () {
                    control.updateValueAndValidity();
                });
            }
            if (isForm) {
                minValue = minInput.value;
            }
            value = parseDate(minValue);
            if (!isDate(value) && !(value instanceof Function)) {
                if (value == null) {
                    return null;
                }
                else if (isForm) {
                    return { minDate: { error: 'minDate is invalid' } };
                }
                else {
                    throw Error('minDate value must be or return a formatted date');
                }
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var d = new Date(parseDate(control.value)).getTime();
            if (!isDate(d)) {
                return { value: true };
            }
            if (value instanceof Function) {
                value = value();
            }
            return d >= new Date(value).getTime() ? null : (isForm ? { minDate: { control: minInput, value: minInput.value } } : { minDate: { value: minValue, control: undefined } });
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var notEqual = function (val) {
        return function (control) {
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = control.value;
            return val !== v ? null : { notEqual: { value: val } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var notEqualTo = function (notEqualControl) {
        /** @type {?} */
        var subscribe = false;
        return function (control) {
            if (!subscribe) {
                subscribe = true;
                notEqualControl.valueChanges.subscribe(function () {
                    control.updateValueAndValidity();
                });
            }
            /** @type {?} */
            var v = control.value;
            if (notEqualControl.value == null && v == null) {
                return null;
            }
            return notEqualControl.value !== v ? null : { notEqualTo: { control: notEqualControl, value: notEqualControl.value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var number = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(v) ? null : { 'number': true };
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var property = function (value) {
        return function (control) {
            var e_1, _a;
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var properties = value.split(',');
            /** @type {?} */
            var obj = control.value;
            /** @type {?} */
            var isValid = true;
            try {
                for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                    var prop = properties_1_1.value;
                    if (obj[prop] == null) {
                        isValid = false;
                        break;
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return))
                        _a.call(properties_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            return isValid ? null : { hasProperty: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var range = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = +control.value;
            return v >= value[0] && v <= value[1] ? null : { range: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var rangeLength = function (value) {
        return function (control) {
            if (!isPresent(value)) {
                return null;
            }
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = control.value;
            return v.length >= value[0] && v.length <= value[1] ? null : { rangeLength: { value: value } };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uuids = {
        '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        'all': /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };
    /** @type {?} */
    var uuid = function (version) {
        return function (control) {
            if (isPresent(forms.Validators.required(control))) {
                return null;
            }
            /** @type {?} */
            var v = control.value;
            /** @type {?} */
            var pattern = uuids[version] || uuids.all;
            return (new RegExp(pattern)).test(v) ? null : { uuid: true };
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var url = function (control) {
        if (isPresent(forms.Validators.required(control))) {
            return null;
        }
        /** @type {?} */
        var v = control.value;
        /* tslint:disable */
        return /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(v) ? null : { 'url': true };
        /* tslint:enable */
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ARRAY_LENGTH_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return ArrayLengthValidator; }),
        multi: true
    };
    var ArrayLengthValidator = /** @class */ (function () {
        function ArrayLengthValidator() {
        }
        /**
         * @return {?}
         */
        ArrayLengthValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = arrayLength(this.arrayLength);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        ArrayLengthValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'arrayLength') {
                        this.validator = arrayLength(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        ArrayLengthValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ArrayLengthValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        ArrayLengthValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[arrayLength][formControlName],[arrayLength][formControl],[arrayLength][ngModel]',
                        providers: [ARRAY_LENGTH_VALIDATOR]
                    },] }
        ];
        ArrayLengthValidator.propDecorators = {
            arrayLength: [{ type: core.Input }]
        };
        return ArrayLengthValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BASE64_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return Base64Validator; }),
        multi: true
    };
    var Base64Validator = /** @class */ (function () {
        function Base64Validator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        Base64Validator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return base64(c);
            };
        Base64Validator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[base64][formControlName],[base64][formControl],[base64][ngModel]',
                        providers: [BASE64_VALIDATOR]
                    },] }
        ];
        return Base64Validator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CREDIT_CARD_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return CreditCardValidator; }),
        multi: true
    };
    var CreditCardValidator = /** @class */ (function () {
        function CreditCardValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        CreditCardValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return creditCard(c);
            };
        CreditCardValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]',
                        providers: [CREDIT_CARD_VALIDATOR]
                    },] }
        ];
        return CreditCardValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DATE_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return DateValidator; }),
        multi: true
    };
    var DateValidator = /** @class */ (function () {
        function DateValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        DateValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return date(c);
            };
        DateValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[date][formControlName],[date][formControl],[date][ngModel]',
                        providers: [DATE_VALIDATOR]
                    },] }
        ];
        return DateValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DATE_ISO_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return DateISOValidator; }),
        multi: true
    };
    var DateISOValidator = /** @class */ (function () {
        function DateISOValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        DateISOValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return dateISO(c);
            };
        DateISOValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[dateISO][formControlName],[dateISO][formControl],[dateISO][ngModel]',
                        providers: [DATE_ISO_VALIDATOR]
                    },] }
        ];
        return DateISOValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DIGITS_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return DigitsValidator; }),
        multi: true
    };
    var DigitsValidator = /** @class */ (function () {
        function DigitsValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        DigitsValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return digits(c);
            };
        DigitsValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[digits][formControlName],[digits][formControl],[digits][ngModel]',
                        providers: [DIGITS_VALIDATOR]
                    },] }
        ];
        return DigitsValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EMAIL_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return EmailValidator; }),
        multi: true
    };
    var EmailValidator = /** @class */ (function () {
        function EmailValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        EmailValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return email(c);
            };
        EmailValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngvemail][formControlName],[ngvemail][formControl],[ngvemail][ngModel]',
                        providers: [EMAIL_VALIDATOR]
                    },] }
        ];
        return EmailValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EQUAL_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return EqualValidator; }),
        multi: true
    };
    var EqualValidator = /** @class */ (function () {
        function EqualValidator() {
        }
        /**
         * @return {?}
         */
        EqualValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = equal(this.equal);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        EqualValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'equal') {
                        this.validator = equal(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        EqualValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        EqualValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        EqualValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[equal][formControlName],[equal][formControl],[equal][ngModel]',
                        providers: [EQUAL_VALIDATOR]
                    },] }
        ];
        EqualValidator.propDecorators = {
            equal: [{ type: core.Input }]
        };
        return EqualValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EQUAL_TO_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return EqualToValidator; }),
        multi: true
    };
    var EqualToValidator = /** @class */ (function () {
        function EqualToValidator() {
        }
        /**
         * @return {?}
         */
        EqualToValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = equalTo(this.equalTo);
            };
        /**
         * @param {?} c
         * @return {?}
         */
        EqualToValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        EqualToValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[equalTo][formControlName],[equalTo][formControl],[equalTo][ngModel]',
                        providers: [EQUAL_TO_VALIDATOR]
                    },] }
        ];
        EqualToValidator.propDecorators = {
            equalTo: [{ type: core.Input }]
        };
        return EqualToValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var GREATER_THAN_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return GreaterThanValidator; }),
        multi: true
    };
    var GreaterThanValidator = /** @class */ (function () {
        function GreaterThanValidator() {
        }
        /**
         * @return {?}
         */
        GreaterThanValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = gt(this.gt);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        GreaterThanValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'gt') {
                        this.validator = gt(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        GreaterThanValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        GreaterThanValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        GreaterThanValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[gt][formControlName],[gt][formControl],[gt][ngModel]',
                        providers: [GREATER_THAN_VALIDATOR]
                    },] }
        ];
        GreaterThanValidator.propDecorators = {
            gt: [{ type: core.Input }]
        };
        return GreaterThanValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var GREATER_THAN_EQUAL_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return GreaterThanEqualValidator; }),
        multi: true
    };
    var GreaterThanEqualValidator = /** @class */ (function () {
        function GreaterThanEqualValidator() {
        }
        /**
         * @return {?}
         */
        GreaterThanEqualValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = gte(this.gte);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        GreaterThanEqualValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'gte') {
                        this.validator = gte(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        GreaterThanEqualValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        GreaterThanEqualValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        GreaterThanEqualValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[gte][formControlName],[gte][formControl],[gte][ngModel]',
                        providers: [GREATER_THAN_EQUAL_VALIDATOR]
                    },] }
        ];
        GreaterThanEqualValidator.propDecorators = {
            gte: [{ type: core.Input }]
        };
        return GreaterThanEqualValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var JSON_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return JSONValidator; }),
        multi: true
    };
    var JSONValidator = /** @class */ (function () {
        function JSONValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        JSONValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return json(c);
            };
        JSONValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[json][formControlName],[json][formControl],[json][ngModel]',
                        providers: [JSON_VALIDATOR]
                    },] }
        ];
        return JSONValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LESS_THAN_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return LessThanValidator; }),
        multi: true
    };
    var LessThanValidator = /** @class */ (function () {
        function LessThanValidator() {
        }
        /**
         * @return {?}
         */
        LessThanValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = lt(this.lt);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        LessThanValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'lt') {
                        this.validator = lt(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        LessThanValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        LessThanValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        LessThanValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[lt][formControlName],[lt][formControl],[lt][ngModel]',
                        providers: [LESS_THAN_VALIDATOR]
                    },] }
        ];
        LessThanValidator.propDecorators = {
            lt: [{ type: core.Input }]
        };
        return LessThanValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LESS_THAN_EQUAL_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return LessThanEqualValidator; }),
        multi: true
    };
    var LessThanEqualValidator = /** @class */ (function () {
        function LessThanEqualValidator() {
        }
        /**
         * @return {?}
         */
        LessThanEqualValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = lte(this.lte);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        LessThanEqualValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'lte') {
                        this.validator = lte(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        LessThanEqualValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        LessThanEqualValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        LessThanEqualValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[lte][formControlName],[lte][formControl],[lte][ngModel]',
                        providers: [LESS_THAN_EQUAL_VALIDATOR]
                    },] }
        ];
        LessThanEqualValidator.propDecorators = {
            lte: [{ type: core.Input }]
        };
        return LessThanEqualValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAX_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return MaxValidator; }),
        multi: true
    };
    var MaxValidator = /** @class */ (function () {
        function MaxValidator() {
        }
        /**
         * @return {?}
         */
        MaxValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = max(this.max);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        MaxValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'max') {
                        this.validator = max(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        MaxValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        MaxValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        MaxValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[max][formControlName],[max][formControl],[max][ngModel]',
                        providers: [MAX_VALIDATOR]
                    },] }
        ];
        MaxValidator.propDecorators = {
            max: [{ type: core.Input }]
        };
        return MaxValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAX_DATE_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return MaxDateValidator; }),
        multi: true
    };
    var MaxDateValidator = /** @class */ (function () {
        function MaxDateValidator() {
        }
        /**
         * @return {?}
         */
        MaxDateValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = maxDate(this.maxDate);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        MaxDateValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'maxDate') {
                        this.validator = maxDate(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        MaxDateValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        MaxDateValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        MaxDateValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[maxDate][formControlName],[maxDate][formControl],[maxDate][ngModel]',
                        providers: [MAX_DATE_VALIDATOR]
                    },] }
        ];
        MaxDateValidator.propDecorators = {
            maxDate: [{ type: core.Input }]
        };
        return MaxDateValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MIN_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return MinValidator; }),
        multi: true
    };
    var MinValidator = /** @class */ (function () {
        function MinValidator() {
        }
        /**
         * @return {?}
         */
        MinValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = min(this.min);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        MinValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'min') {
                        this.validator = min(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        MinValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        MinValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        MinValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[min][formControlName],[min][formControl],[min][ngModel]',
                        providers: [MIN_VALIDATOR]
                    },] }
        ];
        MinValidator.propDecorators = {
            min: [{ type: core.Input }]
        };
        return MinValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MIN_DATE_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return MinDateValidator; }),
        multi: true
    };
    var MinDateValidator = /** @class */ (function () {
        function MinDateValidator() {
        }
        /**
         * @return {?}
         */
        MinDateValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = minDate(this.minDate);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        MinDateValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'minDate') {
                        this.validator = minDate(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        MinDateValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        MinDateValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        MinDateValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[minDate][formControlName],[minDate][formControl],[minDate][ngModel]',
                        providers: [MIN_DATE_VALIDATOR]
                    },] }
        ];
        MinDateValidator.propDecorators = {
            minDate: [{ type: core.Input }]
        };
        return MinDateValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NOT_EQUAL_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return NotEqualValidator; }),
        multi: true
    };
    var NotEqualValidator = /** @class */ (function () {
        function NotEqualValidator() {
        }
        /**
         * @return {?}
         */
        NotEqualValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = notEqual(this.notEqual);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        NotEqualValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'notEqual') {
                        this.validator = notEqual(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        NotEqualValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NotEqualValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        NotEqualValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[notEqual][formControlName],[notEqual][formControl],[notEqual][ngModel]',
                        providers: [NOT_EQUAL_VALIDATOR]
                    },] }
        ];
        NotEqualValidator.propDecorators = {
            notEqual: [{ type: core.Input }]
        };
        return NotEqualValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NOT_EQUAL_TO_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return NotEqualToValidator; }),
        multi: true
    };
    var NotEqualToValidator = /** @class */ (function () {
        function NotEqualToValidator() {
        }
        /**
         * @return {?}
         */
        NotEqualToValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = notEqualTo(this.notEqualTo);
            };
        /**
         * @param {?} c
         * @return {?}
         */
        NotEqualToValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        NotEqualToValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[notEqualTo][formControlName],[notEqualTo][formControl],[notEqualTo][ngModel]',
                        providers: [NOT_EQUAL_TO_VALIDATOR]
                    },] }
        ];
        NotEqualToValidator.propDecorators = {
            notEqualTo: [{ type: core.Input }]
        };
        return NotEqualToValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NUMBER_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return NumberValidator; }),
        multi: true
    };
    var NumberValidator = /** @class */ (function () {
        function NumberValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        NumberValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return number(c);
            };
        NumberValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[number][formControlName],[number][formControl],[number][ngModel]',
                        providers: [NUMBER_VALIDATOR]
                    },] }
        ];
        return NumberValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var PROPERTY_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return PropertyValidator; }),
        multi: true
    };
    var PropertyValidator = /** @class */ (function () {
        function PropertyValidator() {
        }
        /**
         * @return {?}
         */
        PropertyValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = property(this.property);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        PropertyValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'property') {
                        this.validator = property(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        PropertyValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        PropertyValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        PropertyValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[property][formControlName],[property][formControl],[property][ngModel]',
                        providers: [PROPERTY_VALIDATOR]
                    },] }
        ];
        PropertyValidator.propDecorators = {
            property: [{ type: core.Input }]
        };
        return PropertyValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var RANGE_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return RangeValidator; }),
        multi: true
    };
    var RangeValidator = /** @class */ (function () {
        function RangeValidator() {
        }
        /**
         * @return {?}
         */
        RangeValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = range(this.range);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        RangeValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'range') {
                        this.validator = range(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        RangeValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RangeValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        RangeValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[range][formControlName],[range][formControl],[range][ngModel]',
                        providers: [RANGE_VALIDATOR]
                    },] }
        ];
        RangeValidator.propDecorators = {
            range: [{ type: core.Input }]
        };
        return RangeValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var RANGE_LENGTH_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return RangeLengthValidator; }),
        multi: true
    };
    var RangeLengthValidator = /** @class */ (function () {
        function RangeLengthValidator() {
        }
        /**
         * @return {?}
         */
        RangeLengthValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = rangeLength(this.rangeLength);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        RangeLengthValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'rangeLength') {
                        this.validator = rangeLength(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        RangeLengthValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RangeLengthValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        RangeLengthValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]',
                        providers: [RANGE_LENGTH_VALIDATOR]
                    },] }
        ];
        RangeLengthValidator.propDecorators = {
            rangeLength: [{ type: core.Input }]
        };
        return RangeLengthValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var URL_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return UrlValidator; }),
        multi: true
    };
    var UrlValidator = /** @class */ (function () {
        function UrlValidator() {
        }
        /**
         * @param {?} c
         * @return {?}
         */
        UrlValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return url(c);
            };
        UrlValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[url][formControlName],[url][formControl],[url][ngModel]',
                        providers: [URL_VALIDATOR]
                    },] }
        ];
        return UrlValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var UUID_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return UUIDValidator; }),
        multi: true
    };
    var UUIDValidator = /** @class */ (function () {
        function UUIDValidator() {
        }
        /**
         * @return {?}
         */
        UUIDValidator.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.validator = uuid(this.uuid);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        UUIDValidator.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                for (var key in changes) {
                    if (key === 'uuid') {
                        this.validator = uuid(changes[key].currentValue);
                        if (this.onChange) {
                            this.onChange();
                        }
                    }
                }
            };
        /**
         * @param {?} c
         * @return {?}
         */
        UUIDValidator.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this.validator(c);
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        UUIDValidator.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        UUIDValidator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uuid][formControlName],[uuid][formControl],[uuid][ngModel]',
                        providers: [UUID_VALIDATOR]
                    },] }
        ];
        UUIDValidator.propDecorators = {
            uuid: [{ type: core.Input }]
        };
        return UUIDValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CustomValidators = {
        arrayLength: arrayLength,
        base64: base64,
        creditCard: creditCard,
        date: date,
        dateISO: dateISO,
        digits: digits,
        email: email,
        equal: equal,
        equalTo: equalTo,
        gt: gt,
        gte: gte,
        json: json,
        lt: lt,
        lte: lte,
        max: max,
        maxDate: maxDate,
        min: min,
        minDate: minDate,
        notEqual: notEqual,
        notEqualTo: notEqualTo,
        number: number,
        property: property,
        range: range,
        rangeLength: rangeLength,
        url: url,
        uuid: uuid
    };
    /** @type {?} */
    var CustomDirectives = [
        ArrayLengthValidator,
        Base64Validator,
        CreditCardValidator,
        DateValidator,
        DateISOValidator,
        DigitsValidator,
        EmailValidator,
        EqualValidator,
        EqualToValidator,
        GreaterThanValidator,
        GreaterThanEqualValidator,
        JSONValidator,
        LessThanValidator,
        LessThanEqualValidator,
        MaxValidator,
        MaxDateValidator,
        MinValidator,
        MinDateValidator,
        NotEqualValidator,
        NotEqualToValidator,
        NumberValidator,
        PropertyValidator,
        RangeValidator,
        RangeLengthValidator,
        UrlValidator,
        UUIDValidator
    ];
    var CustomFormsModule = /** @class */ (function () {
        function CustomFormsModule() {
        }
        CustomFormsModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [CustomDirectives],
                        exports: [CustomDirectives]
                    },] }
        ];
        return CustomFormsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.CustomValidators = CustomValidators;
    exports.CustomFormsModule = CustomFormsModule;
    exports.ba = ArrayLengthValidator;
    exports.a = arrayLength;
    exports.bb = Base64Validator;
    exports.b = base64;
    exports.bc = CreditCardValidator;
    exports.c = creditCard;
    exports.be = DateISOValidator;
    exports.e = dateISO;
    exports.bd = DateValidator;
    exports.d = date;
    exports.bf = DigitsValidator;
    exports.f = digits;
    exports.bg = EmailValidator;
    exports.g = email;
    exports.bi = EqualToValidator;
    exports.i = equalTo;
    exports.bh = EqualValidator;
    exports.h = equal;
    exports.bk = GreaterThanEqualValidator;
    exports.k = gte;
    exports.bj = GreaterThanValidator;
    exports.j = gt;
    exports.bl = JSONValidator;
    exports.l = json;
    exports.bn = LessThanEqualValidator;
    exports.n = lte;
    exports.bm = LessThanValidator;
    exports.m = lt;
    exports.bp = MaxDateValidator;
    exports.p = maxDate;
    exports.bo = MaxValidator;
    exports.o = max;
    exports.br = MinDateValidator;
    exports.r = minDate;
    exports.bq = MinValidator;
    exports.q = min;
    exports.bt = NotEqualToValidator;
    exports.t = notEqualTo;
    exports.bs = NotEqualValidator;
    exports.s = notEqual;
    exports.bu = NumberValidator;
    exports.u = number;
    exports.bv = PropertyValidator;
    exports.v = property;
    exports.bx = RangeLengthValidator;
    exports.x = rangeLength;
    exports.bw = RangeValidator;
    exports.w = range;
    exports.by = UrlValidator;
    exports.y = url;
    exports.bz = UUIDValidator;
    exports.z = uuid;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWN1c3RvbS12YWxpZGF0b3JzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvdXRpbC9sYW5nLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9hcnJheS1sZW5ndGgvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9iYXNlNjQvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9jcmVkaXQtY2FyZC92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2RhdGUvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9kYXRlLWlzby92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2RpZ2l0cy92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2VtYWlsL3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvZXF1YWwvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9lcXVhbC10by92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2dyZWF0ZXItdGhhbi92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2dyZWF0ZXItdGhhbi1lcXVhbC92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2pzb24vdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9sZXNzLXRoYW4vdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9sZXNzLXRoYW4tZXF1YWwvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9tYXgvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9tYXgtZGF0ZS92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL21pbi92YWxpZGF0b3IudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL21pbi1kYXRlL3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbm90LWVxdWFsL3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbm90LWVxdWFsLXRvL3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbnVtYmVyL3ZhbGlkYXRvci50cyIsIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL3Byb3BlcnR5L3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvcmFuZ2UvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9yYW5nZS1sZW5ndGgvdmFsaWRhdG9yLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC91dWlkL3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvdXJsL3ZhbGlkYXRvci50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvYXJyYXktbGVuZ3RoL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvYmFzZTY0L2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvY3JlZGl0LWNhcmQvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9kYXRlL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvZGF0ZS1pc28vZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9kaWdpdHMvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9lbWFpbC9kaXJlY3RpdmUudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL2VxdWFsL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvZXF1YWwtdG8vZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9ncmVhdGVyLXRoYW4vZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9ncmVhdGVyLXRoYW4tZXF1YWwvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9qc29uL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbGVzcy10aGFuL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbGVzcy10aGFuLWVxdWFsL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbWF4L2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvbWF4LWRhdGUvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9taW4vZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9taW4tZGF0ZS9kaXJlY3RpdmUudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL25vdC1lcXVhbC9kaXJlY3RpdmUudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL25vdC1lcXVhbC10by9kaXJlY3RpdmUudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL251bWJlci9kaXJlY3RpdmUudHMiLCJuZzovL25neC1jdXN0b20tdmFsaWRhdG9ycy9zcmMvYXBwL3Byb3BlcnR5L2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvcmFuZ2UvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC9yYW5nZS1sZW5ndGgvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC91cmwvZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2FwcC91dWlkL2RpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWN1c3RvbS12YWxpZGF0b3JzL3NyYy9hcHAvY3VzdG9tLWZvcm1zLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNQcmVzZW50KG9iajogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUob2JqKTtcbiAgICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlKG9iajogYW55KTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICAvLyBNb21lbnQuanNcbiAgICBpZiAob2JqLl9kIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY29uc3QgZCA9IG9iai5fZCBhcyBEYXRlO1xuICAgICAgY29uc3QgbW9udGggPSArZC5nZXRNb250aCgpICsgMTtcbiAgICAgIGNvbnN0IGRheSA9ICtkLmdldERhdGUoKTtcbiAgICAgIHJldHVybiBgJHtkLmdldEZ1bGxZZWFyKCl9LSR7Zm9ybWF0RGF5T3JNb250aChtb250aCl9LSR7Zm9ybWF0RGF5T3JNb250aChkYXkpfWA7XG4gICAgfVxuXG4gICAgLy8gTmdiRGF0ZVN0cnVjdFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmoueWVhciAhPSBudWxsICYmIG9iai5tb250aCAhPSBudWxsICYmIG9iai5kYXkgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbW9udGggPSArb2JqLm1vbnRoO1xuICAgICAgY29uc3QgZGF5ID0gK29iai5kYXk7XG4gICAgICByZXR1cm4gYCR7b2JqLnllYXJ9LSR7Zm9ybWF0RGF5T3JNb250aChtb250aCl9LSR7Zm9ybWF0RGF5T3JNb250aChkYXkpfWA7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T3JNb250aChtb250aDogbnVtYmVyKTogc3RyaW5nfG51bWJlciB7XG4gIHJldHVybiBtb250aCA8IDEwID8gYDAke21vbnRofWAgOiBtb250aDtcbn1cbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgYXJyYXlMZW5ndGggPSAodmFsdWU6IG51bWJlcik6IFZhbGlkYXRvckZuID0+IHtcbiAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcblxuICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG9iaiA9IGNvbnRyb2wudmFsdWU7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID49ICt2YWx1ZSA/IG51bGwgOiB7IGFycmF5TGVuZ3RoOiB7IG1pbkxlbmd0aDogdmFsdWUgfSB9O1xuICB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgYmFzZTY0OiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qgdjogc3RyaW5nID0gY29udHJvbC52YWx1ZTtcbiAgcmV0dXJuIC9eKD86W0EtWjAtOStcXC9dezR9KSooPzpbQS1aMC05K1xcL117Mn09PXxbQS1aMC05K1xcL117M309fFtBLVowLTkrXFwvXXs0fSkkL2kudGVzdCh2KSA/IG51bGwgOiB7IGJhc2U2NDogdHJ1ZSB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgY3JlZGl0Q2FyZDogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHY6IHN0cmluZyA9IGNvbnRyb2wudmFsdWU7XG5cbiAgY29uc3Qgc2FuaXRpemVkID0gdi5yZXBsYWNlKC9bXjAtOV0rL2csICcnKTtcblxuICAvLyBwcm9ibGVtIHdpdGggY2hyb21lXG4gIC8qIHRzbGludDpkaXNhYmxlICovXG4gIGlmICghKC9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfXwoPzo5NzkyKVxcZHsxMn0pJC8udGVzdChzYW5pdGl6ZWQpKSkge1xuICAgIHJldHVybiB7IGNyZWRpdENhcmQ6IHRydWUgfTtcbiAgfVxuICAvKiB0c2xpbnQ6ZW5hYmxlICovXG5cbiAgbGV0IHN1bSA9IDA7XG4gIGxldCBkaWdpdDtcbiAgbGV0IHRtcE51bTtcbiAgbGV0IHNob3VsZERvdWJsZTtcbiAgZm9yIChsZXQgaSA9IHNhbml0aXplZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGRpZ2l0ID0gc2FuaXRpemVkLnN1YnN0cmluZyhpLCAoaSArIDEpKTtcbiAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuICAgIGlmIChzaG91bGREb3VibGUpIHtcbiAgICAgIHRtcE51bSAqPSAyO1xuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gKCh0bXBOdW0gJSAxMCkgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgfVxuICAgIHNob3VsZERvdWJsZSA9ICFzaG91bGREb3VibGU7XG4gIH1cblxuICBpZiAoQm9vbGVhbigoc3VtICUgMTApID09PSAwID8gc2FuaXRpemVkIDogZmFsc2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4geyBjcmVkaXRDYXJkOiB0cnVlIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzRGF0ZSwgaXNQcmVzZW50LCBwYXJzZURhdGUgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgZGF0ZTogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCB2OiBzdHJpbmcgPSBjb250cm9sLnZhbHVlO1xuICB2ID0gcGFyc2VEYXRlKHYpO1xuICByZXR1cm4gaXNEYXRlKHYpID8gbnVsbCA6IHsgZGF0ZTogdHJ1ZSB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgZGF0ZUlTTzogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHY6IHN0cmluZyA9IGNvbnRyb2wudmFsdWU7XG4gIHJldHVybiAvXlxcZHs0fVtcXC9cXC1dKDA/WzEtOV18MVswMTJdKVtcXC9cXC1dKDA/WzEtOV18WzEyXVswLTldfDNbMDFdKSQvLnRlc3QodikgPyBudWxsIDogeyBkYXRlSVNPOiB0cnVlIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBkaWdpdHM6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB2OiBzdHJpbmcgPSBjb250cm9sLnZhbHVlO1xuICByZXR1cm4gL15cXGQrJC8udGVzdCh2KSA/IG51bGwgOiB7IGRpZ2l0czogdHJ1ZSB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgZW1haWw6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB2OiBzdHJpbmcgPSBjb250cm9sLnZhbHVlO1xuICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICByZXR1cm4gL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC8udGVzdCh2KSA/IG51bGwgOiB7ICdlbWFpbCc6IHRydWUgfTtcbiAgLyogdHNsaW50OmVuYWJsZSAqL1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgZXF1YWwgPSAodmFsOiBhbnkpOiBWYWxpZGF0b3JGbiA9PiB7XG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gICAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdjogYW55ID0gY29udHJvbC52YWx1ZTtcblxuICAgIHJldHVybiB2YWwgPT09IHYgPyBudWxsIDogeyBlcXVhbDogeyB2YWx1ZTogdmFsIH0gfTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgZXF1YWxUbyA9IChlcXVhbENvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRvckZuID0+IHtcbiAgbGV0IHN1YnNjcmliZSA9IGZhbHNlO1xuXG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gICAgaWYgKCFzdWJzY3JpYmUpIHtcbiAgICAgIHN1YnNjcmliZSA9IHRydWU7XG4gICAgICBlcXVhbENvbnRyb2wudmFsdWVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgdjogc3RyaW5nID0gY29udHJvbC52YWx1ZTtcblxuICAgIHJldHVybiBlcXVhbENvbnRyb2wudmFsdWUgPT09IHYgPyBudWxsIDogeyBlcXVhbFRvOiB7IGNvbnRyb2w6IGVxdWFsQ29udHJvbCwgdmFsdWU6IGVxdWFsQ29udHJvbC52YWx1ZSB9IH07XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBndCA9ICh2YWx1ZTogbnVtYmVyKTogVmFsaWRhdG9yRm4gPT4ge1xuICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHY6IG51bWJlciA9ICtjb250cm9sLnZhbHVlO1xuICAgIHJldHVybiB2ID4gK3ZhbHVlID8gbnVsbCA6IHsgZ3Q6IHsgdmFsdWU6IHZhbHVlIH0gfTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNQcmVzZW50IH0gZnJvbSAnLi4vdXRpbC9sYW5nJztcblxuZXhwb3J0IGNvbnN0IGd0ZSA9ICh2YWx1ZTogbnVtYmVyKTogVmFsaWRhdG9yRm4gPT4ge1xuICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHY6IG51bWJlciA9ICtjb250cm9sLnZhbHVlO1xuICAgIHJldHVybiB2ID49ICt2YWx1ZSA/IG51bGwgOiB7IGd0ZTogeyB2YWx1ZTogdmFsdWUgfSB9O1xuICB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QganNvbjogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHY6IHN0cmluZyA9IGNvbnRyb2wudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHYpO1xuXG4gICAgaWYgKEJvb2xlYW4ob2JqKSAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cbiAgcmV0dXJuIHsganNvbjogdHJ1ZSB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgbHQgPSAodmFsdWU6IG51bWJlcik6IFZhbGlkYXRvckZuID0+IHtcbiAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2OiBudW1iZXIgPSArY29udHJvbC52YWx1ZTtcbiAgICByZXR1cm4gdiA8ICt2YWx1ZSA/IG51bGwgOiB7IGx0OiB7IHZhbHVlOiB2YWx1ZSB9IH07XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBsdGUgPSAodmFsdWU6IG51bWJlcik6IFZhbGlkYXRvckZuID0+IHtcbiAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2OiBudW1iZXIgPSArY29udHJvbC52YWx1ZTtcbiAgICByZXR1cm4gdiA8PSArdmFsdWUgPyBudWxsIDogeyBsdGU6IHsgdmFsdWU6IHZhbHVlIH0gfTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNQcmVzZW50IH0gZnJvbSAnLi4vdXRpbC9sYW5nJztcblxuZXhwb3J0IGNvbnN0IG1heCA9ICh2YWx1ZTogbnVtYmVyKTogVmFsaWRhdG9yRm4gPT4ge1xuICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHY6IG51bWJlciA9ICtjb250cm9sLnZhbHVlO1xuICAgIHJldHVybiB2IDw9ICt2YWx1ZSA/IG51bGwgOiB7IG1heDogeyB2YWx1ZTogdmFsdWUgfSB9O1xuICB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgRm9ybUNvbnRyb2wsIE5nTW9kZWwsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNEYXRlLCBpc1ByZXNlbnQsIHBhcnNlRGF0ZSB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBtYXhEYXRlID0gKG1heElucHV0OiBhbnkpOiBWYWxpZGF0b3JGbiA9PiB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IHN1YnNjcmliZSA9IGZhbHNlO1xuICBsZXQgbWF4VmFsdWUgPSBtYXhJbnB1dDtcbiAgY29uc3QgaXNGb3JtID0gbWF4SW5wdXQgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCB8fCBtYXhJbnB1dCBpbnN0YW5jZW9mIE5nTW9kZWw7XG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gICAgaWYgKCFzdWJzY3JpYmUgJiYgaXNGb3JtKSB7XG4gICAgICBzdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgbWF4SW5wdXQudmFsdWVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9ybSkge1xuICAgICAgbWF4VmFsdWUgPSBtYXhJbnB1dC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHBhcnNlRGF0ZShtYXhWYWx1ZSk7XG5cbiAgICBpZiAoIWlzRGF0ZSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGlzRm9ybSkge1xuICAgICAgICByZXR1cm4geyBtYXhEYXRlOiB7IGVycm9yOiAnbWF4RGF0ZSBpcyBpbnZhbGlkJyB9IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignbWF4RGF0ZSB2YWx1ZSBtdXN0IGJlIG9yIHJldHVybiBhIGZvcm1hdHRlZCBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKHBhcnNlRGF0ZShjb250cm9sLnZhbHVlKSkuZ2V0VGltZSgpO1xuXG4gICAgaWYgKCFpc0RhdGUoZCkpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB0cnVlIH07XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQgPD0gbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSA/IG51bGwgOiAoaXNGb3JtID8geyBtYXhEYXRlOiB7IGNvbnRyb2w6IG1heElucHV0LCB2YWx1ZTogbWF4SW5wdXQudmFsdWUgfSB9IDogeyBtYXhEYXRlOiB7IHZhbHVlOiBtYXhWYWx1ZSwgY29udHJvbDogdW5kZWZpbmVkIH0gfSk7XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBtaW4gPSAodmFsdWU6IG51bWJlcik6IFZhbGlkYXRvckZuID0+IHtcbiAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2OiBudW1iZXIgPSArY29udHJvbC52YWx1ZTtcbiAgICByZXR1cm4gdiA+PSArdmFsdWUgPyBudWxsIDogeyBtaW46IHsgdmFsdWU6IHZhbHVlIH0gfTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIEZvcm1Db250cm9sLCBOZ01vZGVsLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzRGF0ZSwgaXNQcmVzZW50LCBwYXJzZURhdGUgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgbWluRGF0ZSA9IChtaW5JbnB1dDogYW55KTogVmFsaWRhdG9yRm4gPT4ge1xuICBsZXQgdmFsdWU7XG4gIGxldCBzdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IG1pblZhbHVlID0gbWluSW5wdXQ7XG4gIGNvbnN0IGlzRm9ybSA9IG1pbklucHV0IGluc3RhbmNlb2YgRm9ybUNvbnRyb2wgfHwgbWluSW5wdXQgaW5zdGFuY2VvZiBOZ01vZGVsO1xuICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuXG4gICAgaWYgKCFzdWJzY3JpYmUgJiYgaXNGb3JtKSB7XG4gICAgICBzdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgbWluSW5wdXQudmFsdWVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9ybSkge1xuICAgICAgbWluVmFsdWUgPSBtaW5JbnB1dC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHBhcnNlRGF0ZShtaW5WYWx1ZSk7XG5cbiAgICBpZiAoIWlzRGF0ZSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGlzRm9ybSkge1xuICAgICAgICByZXR1cm4geyBtaW5EYXRlOiB7IGVycm9yOiAnbWluRGF0ZSBpcyBpbnZhbGlkJyB9IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignbWluRGF0ZSB2YWx1ZSBtdXN0IGJlIG9yIHJldHVybiBhIGZvcm1hdHRlZCBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKHBhcnNlRGF0ZShjb250cm9sLnZhbHVlKSkuZ2V0VGltZSgpO1xuXG4gICAgaWYgKCFpc0RhdGUoZCkpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB0cnVlIH07XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQgPj0gbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSA/IG51bGwgOiAoaXNGb3JtID8geyBtaW5EYXRlOiB7IGNvbnRyb2w6IG1pbklucHV0LCB2YWx1ZTogbWluSW5wdXQudmFsdWUgfSB9IDogeyBtaW5EYXRlOiB7IHZhbHVlOiBtaW5WYWx1ZSwgY29udHJvbDogdW5kZWZpbmVkIH0gfSk7XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBub3RFcXVhbCA9ICh2YWw6IGFueSk6IFZhbGlkYXRvckZuID0+IHtcbiAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2OiBhbnkgPSBjb250cm9sLnZhbHVlO1xuXG4gICAgcmV0dXJuIHZhbCAhPT0gdiA/IG51bGwgOiB7IG5vdEVxdWFsOiB7IHZhbHVlOiB2YWwgfSB9O1xuICB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBub3RFcXVhbFRvID0gKG5vdEVxdWFsQ29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdG9yRm4gPT4ge1xuICBsZXQgc3Vic2NyaWJlID0gZmFsc2U7XG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gICAgaWYgKCFzdWJzY3JpYmUpIHtcbiAgICAgIHN1YnNjcmliZSA9IHRydWU7XG4gICAgICBub3RFcXVhbENvbnRyb2wudmFsdWVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgdjogc3RyaW5nID0gY29udHJvbC52YWx1ZTtcblxuICAgIGlmIChub3RFcXVhbENvbnRyb2wudmFsdWUgPT0gbnVsbCAmJiB2ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBub3RFcXVhbENvbnRyb2wudmFsdWUgIT09IHYgPyBudWxsIDogeyBub3RFcXVhbFRvOiB7IGNvbnRyb2w6IG5vdEVxdWFsQ29udHJvbCwgdmFsdWU6IG5vdEVxdWFsQ29udHJvbC52YWx1ZSB9IH07XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCBudW1iZXI6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xuICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB2OiBzdHJpbmcgPSBjb250cm9sLnZhbHVlO1xuICByZXR1cm4gL14oPzotP1xcZCt8LT9cXGR7MSwzfSg/OixcXGR7M30pKyk/KD86XFwuXFxkKyk/JC8udGVzdCh2KSA/IG51bGwgOiB7ICdudW1iZXInOiB0cnVlIH07XG59O1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNQcmVzZW50IH0gZnJvbSAnLi4vdXRpbC9sYW5nJztcblxuZXhwb3J0IGNvbnN0IHByb3BlcnR5ID0gKHZhbHVlOiBzdHJpbmcpOiBWYWxpZGF0b3JGbiA9PiB7XG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG5cbiAgICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gdmFsdWUuc3BsaXQoJywnKTtcblxuICAgIGNvbnN0IG9iaiA9IGNvbnRyb2wudmFsdWU7XG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAob2JqW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQgPyBudWxsIDogeyBoYXNQcm9wZXJ0eTogeyB2YWx1ZTogdmFsdWUgfSB9O1xuICB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAodmFsdWU6IEFycmF5PG51bWJlcj4pOiBWYWxpZGF0b3JGbiA9PiB7XG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdjogbnVtYmVyID0gK2NvbnRyb2wudmFsdWU7XG4gICAgcmV0dXJuIHYgPj0gdmFsdWVbMF0gJiYgdiA8PSB2YWx1ZVsxXSA/IG51bGwgOiB7IHJhbmdlOiB7IHZhbHVlOiB2YWx1ZSB9IH07XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmV4cG9ydCBjb25zdCByYW5nZUxlbmd0aCA9ICh2YWx1ZTogQXJyYXk8bnVtYmVyPik6IFZhbGlkYXRvckZuID0+IHtcbiAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2OiBzdHJpbmcgPSBjb250cm9sLnZhbHVlO1xuICAgIHJldHVybiB2Lmxlbmd0aCA+PSB2YWx1ZVswXSAmJiB2Lmxlbmd0aCA8PSB2YWx1ZVsxXSA/IG51bGwgOiB7IHJhbmdlTGVuZ3RoOiB7IHZhbHVlOiB2YWx1ZSB9IH07XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL3V0aWwvbGFuZyc7XG5cbmNvbnN0IHV1aWRzID0ge1xuICAnMyc6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tM1swLTlBLUZdezN9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaSxcbiAgJzQnOiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTRbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksXG4gICc1JzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS01WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pLFxuICAnYWxsJzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2lcbn07XG5cbmV4cG9ydCBjb25zdCB1dWlkID0gKHZlcnNpb24/OiBzdHJpbmcpOiBWYWxpZGF0b3JGbiA9PiB7XG4gIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyA9PiB7XG4gICAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgdjogc3RyaW5nID0gY29udHJvbC52YWx1ZTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdXVpZHNbdmVyc2lvbl0gfHwgdXVpZHMuYWxsO1xuXG4gICAgcmV0dXJuIChuZXcgUmVnRXhwKHBhdHRlcm4pKS50ZXN0KHYpID8gbnVsbCA6IHsgdXVpZDogdHJ1ZSB9O1xuICB9O1xufTtcbiIsImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi91dGlsL2xhbmcnO1xuXG5leHBvcnQgY29uc3QgdXJsOiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgaWYgKGlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qgdjogc3RyaW5nID0gY29udHJvbC52YWx1ZTtcbiAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgcmV0dXJuIC9eKD86KD86KD86aHR0cHM/fGZ0cCk6KT9cXC9cXC8pKD86XFxTKyg/OjpcXFMqKT9AKT8oPzooPyEoPzoxMHwxMjcpKD86XFwuXFxkezEsM30pezN9KSg/ISg/OjE2OVxcLjI1NHwxOTJcXC4xNjgpKD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXHUwMGExLVxcdWZmZmYwLTldLSopKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykoPzpcXC4oPzpbYS16XFx1MDBhMS1cXHVmZmZmMC05XS0qKSpbYS16XFx1MDBhMS1cXHVmZmZmMC05XSspKig/OlxcLig/OlthLXpcXHUwMGExLVxcdWZmZmZdezIsfSkpLj8pKD86OlxcZHsyLDV9KT8oPzpbLz8jXVxcUyopPyQvaS50ZXN0KHYpID8gbnVsbCA6IHsgJ3VybCc6IHRydWUgfTtcbiAgLyogdHNsaW50OmVuYWJsZSAqL1xufTtcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIGZvcndhcmRSZWYsIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGFycmF5TGVuZ3RoIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBBUlJBWV9MRU5HVEhfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEFycmF5TGVuZ3RoVmFsaWRhdG9yKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1thcnJheUxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbYXJyYXlMZW5ndGhdW2Zvcm1Db250cm9sXSxbYXJyYXlMZW5ndGhdW25nTW9kZWxdJyxcbiAgcHJvdmlkZXJzOiBbQVJSQVlfTEVOR1RIX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgQXJyYXlMZW5ndGhWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgYXJyYXlMZW5ndGg6IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBhcnJheUxlbmd0aCh0aGlzLmFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnYXJyYXlMZW5ndGgnKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gYXJyYXlMZW5ndGgoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgQkFTRTY0X1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBCYXNlNjRWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2Jhc2U2NF1bZm9ybUNvbnRyb2xOYW1lXSxbYmFzZTY0XVtmb3JtQ29udHJvbF0sW2Jhc2U2NF1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtCQVNFNjRfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBCYXNlNjRWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIGJhc2U2NChjKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgY3JlZGl0Q2FyZCB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgQ1JFRElUX0NBUkRfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENyZWRpdENhcmRWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NyZWRpdENhcmRdW2Zvcm1Db250cm9sTmFtZV0sW2NyZWRpdENhcmRdW2Zvcm1Db250cm9sXSxbY3JlZGl0Q2FyZF1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtDUkVESVRfQ0FSRF9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIENyZWRpdENhcmRWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIGNyZWRpdENhcmQoYyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGRhdGUgfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IERBVEVfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2RhdGVdW2Zvcm1Db250cm9sTmFtZV0sW2RhdGVdW2Zvcm1Db250cm9sXSxbZGF0ZV1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtEQVRFX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gZGF0ZShjKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgZGF0ZUlTTyB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgREFURV9JU09fVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVJU09WYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2RhdGVJU09dW2Zvcm1Db250cm9sTmFtZV0sW2RhdGVJU09dW2Zvcm1Db250cm9sXSxbZGF0ZUlTT11bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtEQVRFX0lTT19WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIERhdGVJU09WYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIGRhdGVJU08oYyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGRpZ2l0cyB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgRElHSVRTX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEaWdpdHNWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2RpZ2l0c11bZm9ybUNvbnRyb2xOYW1lXSxbZGlnaXRzXVtmb3JtQ29udHJvbF0sW2RpZ2l0c11bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtESUdJVFNfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBEaWdpdHNWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIGRpZ2l0cyhjKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgZW1haWwgfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IEVNQUlMX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBFbWFpbFZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbmd2ZW1haWxdW2Zvcm1Db250cm9sTmFtZV0sW25ndmVtYWlsXVtmb3JtQ29udHJvbF0sW25ndmVtYWlsXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW0VNQUlMX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgRW1haWxWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIGVtYWlsKGMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmLCBPbkluaXQsIFNpbXBsZUNoYW5nZXMsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBlcXVhbCB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgRVFVQUxfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEVxdWFsVmFsaWRhdG9yKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlcXVhbF1bZm9ybUNvbnRyb2xOYW1lXSxbZXF1YWxdW2Zvcm1Db250cm9sXSxbZXF1YWxdW25nTW9kZWxdJyxcbiAgcHJvdmlkZXJzOiBbRVFVQUxfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBFcXVhbFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBlcXVhbDogYW55O1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IGVxdWFsKHRoaXMuZXF1YWwpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBlcXVhbChjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEZvcm1Db250cm9sLCBWYWxpZGF0b3JGbiwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBlcXVhbFRvIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBFUVVBTF9UT19WQUxJREFUT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRXF1YWxUb1ZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbZXF1YWxUb11bZm9ybUNvbnRyb2xOYW1lXSxbZXF1YWxUb11bZm9ybUNvbnRyb2xdLFtlcXVhbFRvXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW0VRVUFMX1RPX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgRXF1YWxUb1ZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0IHtcbiAgQElucHV0KCkgZXF1YWxUbzogRm9ybUNvbnRyb2w7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gZXF1YWxUbyh0aGlzLmVxdWFsVG8pO1xuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgZ3QgfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IEdSRUFURVJfVEhBTl9WQUxJREFUT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gR3JlYXRlclRoYW5WYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2d0XVtmb3JtQ29udHJvbE5hbWVdLFtndF1bZm9ybUNvbnRyb2xdLFtndF1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtHUkVBVEVSX1RIQU5fVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBHcmVhdGVyVGhhblZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBndDogbnVtYmVyO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IGd0KHRoaXMuZ3QpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdndCcpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBndChjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgZ3RlIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBHUkVBVEVSX1RIQU5fRVFVQUxfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEdyZWF0ZXJUaGFuRXF1YWxWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2d0ZV1bZm9ybUNvbnRyb2xOYW1lXSxbZ3RlXVtmb3JtQ29udHJvbF0sW2d0ZV1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtHUkVBVEVSX1RIQU5fRVFVQUxfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBHcmVhdGVyVGhhbkVxdWFsVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIGd0ZTogbnVtYmVyO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IGd0ZSh0aGlzLmd0ZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2d0ZScpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBndGUoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGpzb24gfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IEpTT05fVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEpTT05WYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2pzb25dW2Zvcm1Db250cm9sTmFtZV0sW2pzb25dW2Zvcm1Db250cm9sXSxbanNvbl1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtKU09OX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgSlNPTlZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4ganNvbihjKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgbHQgfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IExFU1NfVEhBTl9WQUxJREFUT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGVzc1RoYW5WYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2x0XVtmb3JtQ29udHJvbE5hbWVdLFtsdF1bZm9ybUNvbnRyb2xdLFtsdF1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtMRVNTX1RIQU5fVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBMZXNzVGhhblZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBsdDogbnVtYmVyO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IGx0KHRoaXMubHQpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdsdCcpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBsdChjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgbHRlIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBMRVNTX1RIQU5fRVFVQUxfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExlc3NUaGFuRXF1YWxWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2x0ZV1bZm9ybUNvbnRyb2xOYW1lXSxbbHRlXVtmb3JtQ29udHJvbF0sW2x0ZV1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtMRVNTX1RIQU5fRVFVQUxfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBMZXNzVGhhbkVxdWFsVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIGx0ZTogbnVtYmVyO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IGx0ZSh0aGlzLmx0ZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2x0ZScpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBsdGUoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIGZvcndhcmRSZWYsIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IG1heCB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgTUFYX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXhWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW21heF1bZm9ybUNvbnRyb2xOYW1lXSxbbWF4XVtmb3JtQ29udHJvbF0sW21heF1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtNQVhfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBNYXhWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWF4OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gbWF4KHRoaXMubWF4KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWF4Jykge1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IG1heChjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgbWF4RGF0ZSB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgTUFYX0RBVEVfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heERhdGVWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW21heERhdGVdW2Zvcm1Db250cm9sTmFtZV0sW21heERhdGVdW2Zvcm1Db250cm9sXSxbbWF4RGF0ZV1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtNQVhfREFURV9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIE1heERhdGVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWF4RGF0ZTtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBtYXhEYXRlKHRoaXMubWF4RGF0ZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ21heERhdGUnKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gbWF4RGF0ZShjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgbWluIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBNSU5fVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1pblZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbWluXVtmb3JtQ29udHJvbE5hbWVdLFttaW5dW2Zvcm1Db250cm9sXSxbbWluXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW01JTl9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIE1pblZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtaW46IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBtaW4odGhpcy5taW4pO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtaW4nKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gbWluKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmLCBPbkluaXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBtaW5EYXRlIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBNSU5fREFURV9WQUxJREFUT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWluRGF0ZVZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbWluRGF0ZV1bZm9ybUNvbnRyb2xOYW1lXSxbbWluRGF0ZV1bZm9ybUNvbnRyb2xdLFttaW5EYXRlXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW01JTl9EQVRFX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgTWluRGF0ZVZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtaW5EYXRlO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IG1pbkRhdGUodGhpcy5taW5EYXRlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWluRGF0ZScpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBtaW5EYXRlKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmLCBPbkluaXQsIFNpbXBsZUNoYW5nZXMsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBub3RFcXVhbCB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgTk9UX0VRVUFMX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOb3RFcXVhbFZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbm90RXF1YWxdW2Zvcm1Db250cm9sTmFtZV0sW25vdEVxdWFsXVtmb3JtQ29udHJvbF0sW25vdEVxdWFsXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW05PVF9FUVVBTF9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIE5vdEVxdWFsVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG5vdEVxdWFsOiBhbnk7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gbm90RXF1YWwodGhpcy5ub3RFcXVhbCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ25vdEVxdWFsJykge1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IG5vdEVxdWFsKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgRm9ybUNvbnRyb2wsIFZhbGlkYXRvckZuLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IG5vdEVxdWFsVG8gfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IE5PVF9FUVVBTF9UT19WQUxJREFUT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTm90RXF1YWxUb1ZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbm90RXF1YWxUb11bZm9ybUNvbnRyb2xOYW1lXSxbbm90RXF1YWxUb11bZm9ybUNvbnRyb2xdLFtub3RFcXVhbFRvXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW05PVF9FUVVBTF9UT19WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIE5vdEVxdWFsVG9WYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCB7XG4gIEBJbnB1dCgpIG5vdEVxdWFsVG86IEZvcm1Db250cm9sO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IG5vdEVxdWFsVG8odGhpcy5ub3RFcXVhbFRvKTtcbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IG51bWJlciB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgTlVNQkVSX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOdW1iZXJWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW251bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxbbnVtYmVyXVtmb3JtQ29udHJvbF0sW251bWJlcl1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtOVU1CRVJfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBOdW1iZXJWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIG51bWJlcihjKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgcHJvcGVydHkgfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5cbmNvbnN0IFBST1BFUlRZX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBQcm9wZXJ0eVZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcHJvcGVydHldW2Zvcm1Db250cm9sTmFtZV0sW3Byb3BlcnR5XVtmb3JtQ29udHJvbF0sW3Byb3BlcnR5XVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW1BST1BFUlRZX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgUHJvcGVydHlWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgcHJvcGVydHk6IHN0cmluZztcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBwcm9wZXJ0eSh0aGlzLnByb3BlcnR5KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncHJvcGVydHknKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gcHJvcGVydHkoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIGZvcndhcmRSZWYsIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBSQU5HRV9WQUxJREFUT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFuZ2VWYWxpZGF0b3IpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3JhbmdlXVtmb3JtQ29udHJvbE5hbWVdLFtyYW5nZV1bZm9ybUNvbnRyb2xdLFtyYW5nZV1bbmdNb2RlbF0nLFxuICBwcm92aWRlcnM6IFtSQU5HRV9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIFJhbmdlVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIHJhbmdlOiBbbnVtYmVyXTtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSByYW5nZSh0aGlzLnJhbmdlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmFuZ2UnKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gcmFuZ2UoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIGZvcndhcmRSZWYsIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IHJhbmdlTGVuZ3RoIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBSQU5HRV9MRU5HVEhfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlTGVuZ3RoVmFsaWRhdG9yKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tyYW5nZUxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbcmFuZ2VMZW5ndGhdW2Zvcm1Db250cm9sXSxbcmFuZ2VMZW5ndGhdW25nTW9kZWxdJyxcbiAgcHJvdmlkZXJzOiBbUkFOR0VfTEVOR1RIX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgUmFuZ2VMZW5ndGhWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgcmFuZ2VMZW5ndGg6IFtudW1iZXJdO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IHJhbmdlTGVuZ3RoKHRoaXMucmFuZ2VMZW5ndGgpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyYW5nZUxlbmd0aCcpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSByYW5nZUxlbmd0aChjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgdXJsIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBVUkxfVkFMSURBVE9SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFVybFZhbGlkYXRvciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXJsXVtmb3JtQ29udHJvbE5hbWVdLFt1cmxdW2Zvcm1Db250cm9sXSxbdXJsXVtuZ01vZGVsXScsXG4gIHByb3ZpZGVyczogW1VSTF9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIFVybFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gdXJsKGMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmLCBPbkluaXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyB1dWlkIH0gZnJvbSAnLi92YWxpZGF0b3InO1xuXG5jb25zdCBVVUlEX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBVVUlEVmFsaWRhdG9yKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1dWlkXVtmb3JtQ29udHJvbE5hbWVdLFt1dWlkXVtmb3JtQ29udHJvbF0sW3V1aWRdW25nTW9kZWxdJyxcbiAgcHJvdmlkZXJzOiBbVVVJRF9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIFVVSURWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgdXVpZDtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSB1dWlkKHRoaXMudXVpZCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3V1aWQnKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gdXVpZChjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0b3JGbiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhcnJheUxlbmd0aCB9IGZyb20gJy4vYXJyYXktbGVuZ3RoL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tICcuL2Jhc2U2NC92YWxpZGF0b3InO1xuaW1wb3J0IHsgY3JlZGl0Q2FyZCB9IGZyb20gJy4vY3JlZGl0LWNhcmQvdmFsaWRhdG9yJztcbmltcG9ydCB7IGRhdGUgfSBmcm9tICcuL2RhdGUvdmFsaWRhdG9yJztcbmltcG9ydCB7IGRhdGVJU08gfSBmcm9tICcuL2RhdGUtaXNvL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBkaWdpdHMgfSBmcm9tICcuL2RpZ2l0cy92YWxpZGF0b3InO1xuaW1wb3J0IHsgZW1haWwgfSBmcm9tICcuL2VtYWlsL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBlcXVhbCB9IGZyb20gJy4vZXF1YWwvdmFsaWRhdG9yJztcbmltcG9ydCB7IGVxdWFsVG8gfSBmcm9tICcuL2VxdWFsLXRvL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBndCB9IGZyb20gJy4vZ3JlYXRlci10aGFuL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBndGUgfSBmcm9tICcuL2dyZWF0ZXItdGhhbi1lcXVhbC92YWxpZGF0b3InO1xuaW1wb3J0IHsganNvbiB9IGZyb20gJy4vanNvbi92YWxpZGF0b3InO1xuaW1wb3J0IHsgbHQgfSBmcm9tICcuL2xlc3MtdGhhbi92YWxpZGF0b3InO1xuaW1wb3J0IHsgbHRlIH0gZnJvbSAnLi9sZXNzLXRoYW4tZXF1YWwvdmFsaWRhdG9yJztcbmltcG9ydCB7IG1heCB9IGZyb20gJy4vbWF4L3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBtYXhEYXRlIH0gZnJvbSAnLi9tYXgtZGF0ZS92YWxpZGF0b3InO1xuaW1wb3J0IHsgbWluIH0gZnJvbSAnLi9taW4vdmFsaWRhdG9yJztcbmltcG9ydCB7IG1pbkRhdGUgfSBmcm9tICcuL21pbi1kYXRlL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBub3RFcXVhbCB9IGZyb20gJy4vbm90LWVxdWFsL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBub3RFcXVhbFRvIH0gZnJvbSAnLi9ub3QtZXF1YWwtdG8vdmFsaWRhdG9yJztcbmltcG9ydCB7IG51bWJlciB9IGZyb20gJy4vbnVtYmVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJy4vcHJvcGVydHkvdmFsaWRhdG9yJztcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi9yYW5nZS92YWxpZGF0b3InO1xuaW1wb3J0IHsgcmFuZ2VMZW5ndGggfSBmcm9tICcuL3JhbmdlLWxlbmd0aC92YWxpZGF0b3InO1xuaW1wb3J0IHsgdXVpZCB9IGZyb20gJy4vdXVpZC92YWxpZGF0b3InO1xuaW1wb3J0IHsgdXJsIH0gZnJvbSAnLi91cmwvdmFsaWRhdG9yJztcblxuaW1wb3J0IHsgQXJyYXlMZW5ndGhWYWxpZGF0b3IgfSBmcm9tICcuL2FycmF5LWxlbmd0aC9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQmFzZTY0VmFsaWRhdG9yIH0gZnJvbSAnLi9iYXNlNjQvZGlyZWN0aXZlJztcbmltcG9ydCB7IENyZWRpdENhcmRWYWxpZGF0b3IgfSBmcm9tICcuL2NyZWRpdC1jYXJkL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEYXRlVmFsaWRhdG9yIH0gZnJvbSAnLi9kYXRlL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEYXRlSVNPVmFsaWRhdG9yIH0gZnJvbSAnLi9kYXRlLWlzby9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRGlnaXRzVmFsaWRhdG9yIH0gZnJvbSAnLi9kaWdpdHMvZGlyZWN0aXZlJztcbmltcG9ydCB7IEVtYWlsVmFsaWRhdG9yIH0gZnJvbSAnLi9lbWFpbC9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRXF1YWxWYWxpZGF0b3IgfSBmcm9tICcuL2VxdWFsL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBFcXVhbFRvVmFsaWRhdG9yIH0gZnJvbSAnLi9lcXVhbC10by9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgR3JlYXRlclRoYW5WYWxpZGF0b3IgfSBmcm9tICcuL2dyZWF0ZXItdGhhbi9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgR3JlYXRlclRoYW5FcXVhbFZhbGlkYXRvciB9IGZyb20gJy4vZ3JlYXRlci10aGFuLWVxdWFsL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBKU09OVmFsaWRhdG9yIH0gZnJvbSAnLi9qc29uL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBMZXNzVGhhblZhbGlkYXRvciB9IGZyb20gJy4vbGVzcy10aGFuL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBMZXNzVGhhbkVxdWFsVmFsaWRhdG9yIH0gZnJvbSAnLi9sZXNzLXRoYW4tZXF1YWwvZGlyZWN0aXZlJztcbmltcG9ydCB7IE1heFZhbGlkYXRvciB9IGZyb20gJy4vbWF4L2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNYXhEYXRlVmFsaWRhdG9yIH0gZnJvbSAnLi9tYXgtZGF0ZS9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWluVmFsaWRhdG9yIH0gZnJvbSAnLi9taW4vZGlyZWN0aXZlJztcbmltcG9ydCB7IE1pbkRhdGVWYWxpZGF0b3IgfSBmcm9tICcuL21pbi1kYXRlL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOb3RFcXVhbFZhbGlkYXRvciB9IGZyb20gJy4vbm90LWVxdWFsL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOb3RFcXVhbFRvVmFsaWRhdG9yIH0gZnJvbSAnLi9ub3QtZXF1YWwtdG8vZGlyZWN0aXZlJztcbmltcG9ydCB7IE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4vbnVtYmVyL2RpcmVjdGl2ZSc7XG5pbXBvcnQgeyBQcm9wZXJ0eVZhbGlkYXRvciB9IGZyb20gJy4vcHJvcGVydHkvZGlyZWN0aXZlJztcbmltcG9ydCB7IFJhbmdlVmFsaWRhdG9yIH0gZnJvbSAnLi9yYW5nZS9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmFuZ2VMZW5ndGhWYWxpZGF0b3IgfSBmcm9tICcuL3JhbmdlLWxlbmd0aC9kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVXJsVmFsaWRhdG9yIH0gZnJvbSAnLi91cmwvZGlyZWN0aXZlJztcbmltcG9ydCB7IFVVSURWYWxpZGF0b3IgfSBmcm9tICcuL3V1aWQvZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IEN1c3RvbVZhbGlkYXRvcnMgPSB7XG4gIGFycmF5TGVuZ3RoLFxuICBiYXNlNjQsXG4gIGNyZWRpdENhcmQsXG4gIGRhdGUsXG4gIGRhdGVJU08sXG4gIGRpZ2l0cyxcbiAgZW1haWwsXG4gIGVxdWFsLFxuICBlcXVhbFRvLFxuICBndCxcbiAgZ3RlLFxuICBqc29uLFxuICBsdCxcbiAgbHRlLFxuICBtYXgsXG4gIG1heERhdGUsXG4gIG1pbixcbiAgbWluRGF0ZSxcbiAgbm90RXF1YWwsXG4gIG5vdEVxdWFsVG8sXG4gIG51bWJlcixcbiAgcHJvcGVydHksXG4gIHJhbmdlLFxuICByYW5nZUxlbmd0aCxcbiAgdXJsLFxuICB1dWlkXG59O1xuXG5jb25zdCBDdXN0b21EaXJlY3RpdmVzID0gW1xuICBBcnJheUxlbmd0aFZhbGlkYXRvcixcbiAgQmFzZTY0VmFsaWRhdG9yLFxuICBDcmVkaXRDYXJkVmFsaWRhdG9yLFxuICBEYXRlVmFsaWRhdG9yLFxuICBEYXRlSVNPVmFsaWRhdG9yLFxuICBEaWdpdHNWYWxpZGF0b3IsXG4gIEVtYWlsVmFsaWRhdG9yLFxuICBFcXVhbFZhbGlkYXRvcixcbiAgRXF1YWxUb1ZhbGlkYXRvcixcbiAgR3JlYXRlclRoYW5WYWxpZGF0b3IsXG4gIEdyZWF0ZXJUaGFuRXF1YWxWYWxpZGF0b3IsXG4gIEpTT05WYWxpZGF0b3IsXG4gIExlc3NUaGFuVmFsaWRhdG9yLFxuICBMZXNzVGhhbkVxdWFsVmFsaWRhdG9yLFxuICBNYXhWYWxpZGF0b3IsXG4gIE1heERhdGVWYWxpZGF0b3IsXG4gIE1pblZhbGlkYXRvcixcbiAgTWluRGF0ZVZhbGlkYXRvcixcbiAgTm90RXF1YWxWYWxpZGF0b3IsXG4gIE5vdEVxdWFsVG9WYWxpZGF0b3IsXG4gIE51bWJlclZhbGlkYXRvcixcbiAgUHJvcGVydHlWYWxpZGF0b3IsXG4gIFJhbmdlVmFsaWRhdG9yLFxuICBSYW5nZUxlbmd0aFZhbGlkYXRvcixcbiAgVXJsVmFsaWRhdG9yLFxuICBVVUlEVmFsaWRhdG9yXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtDdXN0b21EaXJlY3RpdmVzXSxcbiAgZXhwb3J0czogW0N1c3RvbURpcmVjdGl2ZXNdXG59KVxuZXhwb3J0IGNsYXNzIEN1c3RvbUZvcm1zTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbIlZhbGlkYXRvcnMiLCJGb3JtQ29udHJvbCIsIk5nTW9kZWwiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiTkdfVkFMSURBVE9SUyIsImZvcndhcmRSZWYiLCJEaXJlY3RpdmUiLCJJbnB1dCIsIk5nTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLHVCQUEwQixHQUFRO1FBQ2hDLE9BQU8sR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDO0tBQzFDOzs7OztBQUVELG9CQUF1QixHQUFRO1FBQzdCLElBQUk7O1lBQ0YsSUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUMvQjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUM7U0FDZDtLQUNGOzs7OztBQUVELHVCQUEwQixHQUFRO1FBQ2hDLElBQUk7O1lBRUYsSUFBSSxHQUFHLENBQUMsRUFBRSxZQUFZLElBQUksRUFBRTs7Z0JBQzFCLElB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