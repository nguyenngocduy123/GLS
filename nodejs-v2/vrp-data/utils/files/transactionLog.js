/*
 * Copyright (C) 2018 Singapore Institute of Manufacturing Technology - All Rights Reserved
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */
'use strict';

const log = require('log4js').getLogger('Data');

const _ = require('lodash');
const moment = require('moment');
const Promise = require('bluebird');
const Jimp = require('jimp');
const JSZip = require('jszip');
const excel = require('excel4node');
const { JOB } = require('../../classes');
const vrpSql = require('../../../vrp-sql');
const vrpEnum = require('../../../enum');
const vrpUtils = require('../../../vrp-common/utils');
const vrpConfig = require('../../../configuration');
const vrpMapUtils = require('../../../vrp-map-service/map-utils');

const TIMEZONE = vrpConfig.get('timezone');
const MAX_RECORDS = 5000; // maximum number of rows (i.e. jobs) allowed if requirePhotos is enabled
const FOLDER_NOTE_PHOTOS = 'Note Photos'; // name of folder to store note photos
const FOLDER_POD = 'Proof of Delivery'; // name of folder to store proof of delivery
const IMAGE_EXT = 'jpg';

const EXCEL_COLUMNS = [{
    title: 'Order Id',
    table: 'DeliveryMaster',
    column: 'Id',
}, {
    title: 'Job Type',
    column: 'JobType',
}, {
    title: 'Job Sequence',
    column: 'JobSequence',
}, {
    title: 'Job Status',
    column: 'Status',
    fn: (data) => JOB.getStatusLabel({ Status: data }),
}, {
    title: 'Delivery Time',
    column: 'ActualDeliveryTime',
}, {
    title: 'Vehicle Id',
    table: 'DeliveryMaster',
    column: 'VehicleId',
}, {
    title: 'Position in Route',
    column: 'EngineRouteSeqNum',
}, {
    title: 'Address',
    column: 'Address',
}, {
    title: 'Postal',
    column: 'Postal',
}, {
    title: 'Contact Name',
    column: 'ContactName',
}, {
    title: 'Contact Phone',
    column: 'ContactPhone',
}, {
    title: 'Contact Email',
    column: 'ContactEmail',
}, {
    title: 'Start Time Window',
    column: 'StartTimeWindow',
}, {
    title: 'End Time Window',
    column: 'EndTimeWindow',
}, {
    title: 'Service Time',
    column: 'ServiceTime',
}, {
    title: 'Note From Planner',
    column: 'NoteFromPlanner',
    fn: (data) => JOB.noteColumnToString(data),
}, {
    title: 'Note From Driver',
    column: 'NoteFromDriver',
    fn: (data) => JOB.noteColumnToString(data),
}, {
    title: 'Distance (meters)',
    column: [
        'NoteFromDriver',
        'Lat',
        'Lng',
    ],
    fn: (data, addressLat, addressLng) => {
        const driverLocation = _.find(data, (note) => (note.key === 'ActualDeliveryLocation' && !_.isEmpty(note.value)));

        if (driverLocation) {
            const address = { lat: addressLat, lon: addressLng };
            const actualPosition = { lat: _.get(driverLocation, 'value.lat'), lon: _.get(driverLocation, 'value.lng') };

            const distance = vrpMapUtils.calGreatCircleDist(address, actualPosition);

            return Number(distance).toFixed(2); // 2 decimal places only
        }
    },
}, {
    title: 'Priority',
    table: 'DeliveryMaster',
    column: 'Priority',
}, {
    title: 'Customer Name',
    table: 'DeliveryMaster',
    column: 'CustomerName',
}, {
    title: 'Customer Phone',
    table: 'DeliveryMaster',
    column: 'CustomerPhone',
}, {
    title: 'Customer Email',
    table: 'DeliveryMaster',
    column: 'CustomerEmail',
}, {
    title: 'Last Attempted By Driver',
    table: 'DeliveryMaster',
    column: 'LastAttemptedByDriver',
}, {
    title: 'Last Attempted By Plate Number',
    table: 'DeliveryMaster',
    column: 'LastAttemptedByPlateNumber',
}, {
    title: 'Job Items',
    table: 'DeliveryItems',
    fn: (data) => {
        const qtyArr = _.map(data, (item) => {
            const itemQty = _.toNumber(_.get(item, 'ItemQty', 0));
            return `${itemQty} ${item.ItemId}`;
        });
        return _.join(qtyArr, ', ');
    },
}, {
    title: 'Actual Job Items',
    table: 'DeliveryItems',
    fn: (data) => {
        const qtyArr = _.map(data, (item) => {
            const itemQty = _.toNumber(_.get(item, 'ActualItemQty', 0));
            return `${itemQty} ${item.ItemId}`;
        });
        return _.join(qtyArr, ', ');
    },
}, {
    title: 'Verification Code',
    table: 'VerificationCode',
    column: 'Code',
}, {
    title: 'Vehicle Restriction',
    table: 'DeliveryMaster',
    column: 'VehicleRestriction',
}];

/**
 * Generate transaction log for certain period of time defined by `dateScope`. Records are
 * also filtered based on UserGroup defined by `authzScope`. Default `date` is today.
 *
 * @param {Object} scopes  `req.scopes` database scopes generated by `Scope` middleware
 * @param {Object} scopes.authzScope  Determines what records can be viewed by the logged-in user
 * @param {Object} scopes.dateScope  Determines records of which dates to return
 * @param {Boolean} [requirePhotos=false]  Set true to download note photos and proof of delivery
 * @returns {buffer}  Zip file
 */
module.exports = async function transactionLog(scopes, requirePhotos) {
    const startDate = _.get(scopes, 'date.method[1]'); // get the date values from query string
    const endDate = _.isEmpty(_.get(scopes, 'date.method[2]')) ? startDate : scopes.date.method[2];
    requirePhotos = vrpUtils.toBoolean(requirePhotos);

    // args validation
    if (_.isNil(startDate) || !moment(startDate).isValid()) {
        throw new Error('StartDate is invalid.');
    } else if (_.isNil(endDate) || !moment(endDate).isValid()) {
        throw new Error('EndDate is invalid.');
    } else if (_.isNil(requirePhotos)) {
        requirePhotos = false;
    }

    const startDateStr = moment(startDate).format(vrpEnum.DateFormat.DATE);
    const endDateStr = moment(endDate).format(vrpEnum.DateFormat.DATE);
    log.trace(`<TransactionLog> ${startDateStr} to ${endDateStr}, photos ${requirePhotos}`);

    // create zip file
    const zip = new JSZip();

    // create excel file to store transaction log information
    const workbook = new excel.Workbook({
        dateFormat: 'm/d/yy hh:mm:ss',
    });

    const worksheet = workbook.addWorksheet('TransactionLog');

    // get jobs information
    const jobs = await vrpSql.DeliveryDetail.scope(scopes.date).findAll({
        where: {
            Status: {
                [vrpSql.sequelize.Op.notIn]: [ // generate log for completed orders only
                    JOB.STATUS.PENDING,
                    JOB.STATUS.EXPECTED_TO_BE_LATE,
                ],
            },
        },
        include: [
            vrpSql.DeliveryMaster.scope(scopes.authz),
            vrpSql.DeliveryItem,
            vrpSql.VerificationCode,
        ],
        order: ['ActualDeliveryTime'], // order by ActualDeliveryTime
    });

    // get photos information
    let notePhotos;
    let pods;
    if (requirePhotos) {
        // create folders to store photos
        zip.folder(FOLDER_NOTE_PHOTOS);
        zip.folder(FOLDER_POD);

        if (jobs.length > MAX_RECORDS) {
            throw new Error(`Photos for transaction log can only be downloaded for at most ${MAX_RECORDS} jobs.`);

        } else {
            const whereQuery = {
                where: { DeliveryDetailId: _.map(jobs, 'Id') },
            };

            [notePhotos, pods] = await Promise.all([
                vrpSql.DeliveryNote.findAll(whereQuery),
                vrpSql.DeliveryPOD.findAll(whereQuery),
            ]);
        }
    }

    await Promise.each(jobs, async (job, rowNum) => {
        populateExcel(job, rowNum);

        if (requirePhotos) {
            // add photos
            const notes = _.remove(notePhotos, { DeliveryDetailId: job.Id });
            const pod = _.first(_.remove(pods, { DeliveryDetailId: job.Id })); // ok to use _.first because guaranteed one only

            // add background to photo if necessary
            let signature;
            try {
                signature = await addWhiteBackground(_.get(pod, 'Signature'));
            } catch (err) {
                signature = _.get(pod, 'Signature'); // use signature without background if unable to add background
            }

            await Promise.all([
                addPhotoToZip(FOLDER_NOTE_PHOTOS, job, _.map(notes, 'Photo')),
                addPhotoToZip(FOLDER_POD, job, [signature, _.get(pod, 'Photo')]),
            ]);
        }
    });

    const buffer = await workbook.writeToBuffer();

    return zip
        .file(`transaction_log_${startDateStr}_to_${endDateStr}.xlsx`, buffer)
        .generateAsync({
            type: 'uint8array',
        });

    function populateExcel(job, rowNum) {
        _.each(EXCEL_COLUMNS, (mapping, columnNum) => {
            // set column header
            worksheet.cell(1, (columnNum + 1)).string(mapping.title);

            // get cell value (might be multiple columns for mapping.fn)
            const values = _.map(_.concat(mapping.column), (column) => {
                // get object key to get the value from `job` object
                const objectKey = _.compact([mapping.table, column]);

                // get value from `job` object
                return _.get(job, _.join(objectKey, '.'));
            });

            // assume there is no additional processing required
            let cellValue = _.first(values);

            // do additional processing if necessary
            if (mapping.fn) {
                cellValue = mapping.fn(...values);
            }

            // set value in cell
            const cell = worksheet.cell((rowNum + 2), (columnNum + 1));
            if (_.isString(cellValue)) {
                cell.string(cellValue);
            } else if (_.isNumber(cellValue)) {
                cell.number(cellValue);
            } else if (cellValue instanceof Date) {
                // https://github.com/natergj/excel4node/issues/155
                const withoutTimezone = moment(cellValue).utcOffset(TIMEZONE).format('YYYY-MM-DDTHH:mm:ss[Z]');
                cell.date(withoutTimezone);
            }
        });
    }

    function addPhotoToZip(folderName, job, photos) {
        const folder = zip.folder(folderName);
        photos = vrpUtils.toArray(photos);
        return Promise.each(photos, (photo, i) => {
            return folder.file(`${job.DeliveryMasterId}_${_.toLower(job.JobType)}_${i + 1}.${IMAGE_EXT}`, photo);
        });
    }
};

/**
 * Add white background to image
 *
 * @param {Buffer} imageBuffer  Image buffer
 * @returns {Promise<buffer>}  todo
 */
function addWhiteBackground(imageBuffer) {
    if (_.isNil(imageBuffer)) {
        return Promise.resolve();
    }

    return Jimp.read(imageBuffer).then((image) => {
        return new Promise((resolve, reject) => {
            image
                .rgba(false)
                .background(0xFFFFFFFF)
                .getBuffer(Jimp.MIME_JPEG, (err, buffer) => {
                    if (_.isNil(err)) {
                        resolve(buffer);
                    } else {
                        reject(err);
                    }
                });
        });
    });
}
